//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_WAREHOUSE_URL = new InjectionToken<string>('API_WAREHOUSE_URL');

export interface IWarehouseService {
    /**
     * @param body (optional) 
     * @return OK
     */
    createCategory(body: ApiCreateCategoryModelReq | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    listCategory(body: ApiListCategoryModelReq | undefined): Observable<ApiListCategoryModelResIEnumerableApiResponse>;
    /**
     * @param files (optional) 
     * @return OK
     */
    upload(files: FileParameter[] | undefined): Observable<UploadFileResponseDTOApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    list(body: ItemFileManagerRequestDTO | undefined): Observable<ItemFileManagerResponseDTOIEnumerableApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createInventory(body: InventoryWhCreateModelReq | undefined): Observable<InventoryWhCreateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateInventory(body: InventoryWhUpdateModelReq | undefined): Observable<InventoryWhUpdateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deleteInventory(body: InventoryWhDeleteModelReq | undefined): Observable<InventoryWhDeleteModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    listInventory(body: InventoryWhListModelReq | undefined): Observable<InventoryWhListModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    notificationByUserId(body: GetNotificationByUserIdModelReq | undefined): Observable<GetNotificationByUserIdModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createNotification(body: CreateNotificationModelReq | undefined): Observable<CreateNotificationModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createProduct(body: ProductWhCreateModelReq | undefined): Observable<ProductWhCreateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateProduct(body: ProductWhUpdateModelReq | undefined): Observable<ProductWhUpdateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deleteProduct(body: ProductWhDeleteModelReq | undefined): Observable<ProductWhDeleteModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    listProduct(body: ProductWhListModelReq | undefined): Observable<ProductWhListModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    detailProduct(body: ProductWhDetailModelReq | undefined): Observable<ProductWhDetailModelResApiResponse>;
    /**
     * @return OK
     */
    getCount(): Observable<Int32ApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createSupplier(body: SupplierWhCreateModelReq | undefined): Observable<SupplierWhCreateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateSupplier(body: SupplierWhUpdateModelReq | undefined): Observable<SupplierWhUpdateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deleteSupplier(body: SupplierWhDeleteModelReq | undefined): Observable<SupplierWhDeleteModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    listSupplier(body: SupplierWhListModelReq | undefined): Observable<SupplierWhListModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    detailSupplier(body: SupplierWhDetailModelReq | undefined): Observable<SupplierWhDetailModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createTransaction(body: TransactionWhCreateModelReq | undefined): Observable<TransactionWhCreateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateTransaction(body: TransactionWhUpdateModelReq | undefined): Observable<TransactionWhUpdateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deleteTransaction(body: TransactionWhDeleteModelReq | undefined): Observable<TransactionWhDeleteModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    listTransaction(body: TransactionWhListModelReq | undefined): Observable<TransactionWhListModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    detailTransaction(body: TransactionWhDetailModelReq | undefined): Observable<TransactionWhDetailModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createUnit(body: UnitWhCreateModelReq | undefined): Observable<UnitWhCreateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateUnit(body: UnitWhUpdateModelReq | undefined): Observable<UnitWhUpdateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deleteUnit(body: UnitWhDeleteModelReq | undefined): Observable<UnitWhDeleteModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    listUnit(body: UnitWhListModelReq | undefined): Observable<UnitWhListModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    detailUnit(body: UnitWhDetailModelReq | undefined): Observable<UnitWhDetailModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createWarehouse(body: WarehouseCreateModelReq | undefined): Observable<WarehouseCreateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateWarehouse(body: WarehouseUpdateModelReq | undefined): Observable<WarehouseUpdateModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deleteWarehouse(body: WarehouseDeleteModelReq | undefined): Observable<WarehouseDeleteModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    listWarehouse(body: WarehouseListModelReq | undefined): Observable<WarehouseListModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    getWarehouseById(body: WarehouseWhDetailByIdModelReq | undefined): Observable<WarehouseWhDetailByIdModelResApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    detailWarehouse(body: WarehouseWhDetailModelReq | undefined): Observable<WarehouseWhDetailModelResApiResponse>;
}

@Injectable()
export class WarehouseService implements IWarehouseService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_WAREHOUSE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCategory(body: ApiCreateCategoryModelReq | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/category/create-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    listCategory(body: ApiListCategoryModelReq | undefined): Observable<ApiListCategoryModelResIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/category/list-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiListCategoryModelResIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiListCategoryModelResIEnumerableApiResponse>;
        }));
    }

    protected processListCategory(response: HttpResponseBase): Observable<ApiListCategoryModelResIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiListCategoryModelResIEnumerableApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiListCategoryModelResIEnumerableApiResponse>(null as any);
    }

    /**
     * @param files (optional) 
     * @return OK
     */
    upload(files: FileParameter[] | undefined): Observable<UploadFileResponseDTOApiResponse> {
        let url_ = this.baseUrl + "/api/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadFileResponseDTOApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadFileResponseDTOApiResponse>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<UploadFileResponseDTOApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploadFileResponseDTOApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadFileResponseDTOApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    list(body: ItemFileManagerRequestDTO | undefined): Observable<ItemFileManagerResponseDTOIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/file/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemFileManagerResponseDTOIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemFileManagerResponseDTOIEnumerableApiResponse>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ItemFileManagerResponseDTOIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ItemFileManagerResponseDTOIEnumerableApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemFileManagerResponseDTOIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createInventory(body: InventoryWhCreateModelReq | undefined): Observable<InventoryWhCreateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/inventory/create-inventory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInventory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryWhCreateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryWhCreateModelResApiResponse>;
        }));
    }

    protected processCreateInventory(response: HttpResponseBase): Observable<InventoryWhCreateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InventoryWhCreateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryWhCreateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateInventory(body: InventoryWhUpdateModelReq | undefined): Observable<InventoryWhUpdateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/inventory/update-inventory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInventory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryWhUpdateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryWhUpdateModelResApiResponse>;
        }));
    }

    protected processUpdateInventory(response: HttpResponseBase): Observable<InventoryWhUpdateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InventoryWhUpdateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryWhUpdateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteInventory(body: InventoryWhDeleteModelReq | undefined): Observable<InventoryWhDeleteModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/inventory/delete-inventory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInventory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryWhDeleteModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryWhDeleteModelResApiResponse>;
        }));
    }

    protected processDeleteInventory(response: HttpResponseBase): Observable<InventoryWhDeleteModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InventoryWhDeleteModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryWhDeleteModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    listInventory(body: InventoryWhListModelReq | undefined): Observable<InventoryWhListModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/inventory/list-inventory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListInventory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryWhListModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryWhListModelResApiResponse>;
        }));
    }

    protected processListInventory(response: HttpResponseBase): Observable<InventoryWhListModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InventoryWhListModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryWhListModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    notificationByUserId(body: GetNotificationByUserIdModelReq | undefined): Observable<GetNotificationByUserIdModelResApiResponse> {
        let url_ = this.baseUrl + "/api/notification/notification-by-user-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotificationByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotificationByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationByUserIdModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationByUserIdModelResApiResponse>;
        }));
    }

    protected processNotificationByUserId(response: HttpResponseBase): Observable<GetNotificationByUserIdModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetNotificationByUserIdModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationByUserIdModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createNotification(body: CreateNotificationModelReq | undefined): Observable<CreateNotificationModelResApiResponse> {
        let url_ = this.baseUrl + "/api/notification/create-notification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateNotificationModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateNotificationModelResApiResponse>;
        }));
    }

    protected processCreateNotification(response: HttpResponseBase): Observable<CreateNotificationModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateNotificationModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateNotificationModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createProduct(body: ProductWhCreateModelReq | undefined): Observable<ProductWhCreateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/product/create-product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWhCreateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWhCreateModelResApiResponse>;
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<ProductWhCreateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductWhCreateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductWhCreateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProduct(body: ProductWhUpdateModelReq | undefined): Observable<ProductWhUpdateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/product/update-product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWhUpdateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWhUpdateModelResApiResponse>;
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductWhUpdateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductWhUpdateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductWhUpdateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteProduct(body: ProductWhDeleteModelReq | undefined): Observable<ProductWhDeleteModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/product/delete-product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWhDeleteModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWhDeleteModelResApiResponse>;
        }));
    }

    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductWhDeleteModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductWhDeleteModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductWhDeleteModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    listProduct(body: ProductWhListModelReq | undefined): Observable<ProductWhListModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/product/list-product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWhListModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWhListModelResApiResponse>;
        }));
    }

    protected processListProduct(response: HttpResponseBase): Observable<ProductWhListModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductWhListModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductWhListModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    detailProduct(body: ProductWhDetailModelReq | undefined): Observable<ProductWhDetailModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/product/detail-product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWhDetailModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWhDetailModelResApiResponse>;
        }));
    }

    protected processDetailProduct(response: HttpResponseBase): Observable<ProductWhDetailModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductWhDetailModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductWhDetailModelResApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getCount(): Observable<Int32ApiResponse> {
        let url_ = this.baseUrl + "/api/queue/get-count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ApiResponse>;
        }));
    }

    protected processGetCount(response: HttpResponseBase): Observable<Int32ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32ApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createSupplier(body: SupplierWhCreateModelReq | undefined): Observable<SupplierWhCreateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/supplier/create-supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierWhCreateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierWhCreateModelResApiResponse>;
        }));
    }

    protected processCreateSupplier(response: HttpResponseBase): Observable<SupplierWhCreateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SupplierWhCreateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierWhCreateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSupplier(body: SupplierWhUpdateModelReq | undefined): Observable<SupplierWhUpdateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/supplier/update-supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierWhUpdateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierWhUpdateModelResApiResponse>;
        }));
    }

    protected processUpdateSupplier(response: HttpResponseBase): Observable<SupplierWhUpdateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SupplierWhUpdateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierWhUpdateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteSupplier(body: SupplierWhDeleteModelReq | undefined): Observable<SupplierWhDeleteModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/supplier/delete-supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierWhDeleteModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierWhDeleteModelResApiResponse>;
        }));
    }

    protected processDeleteSupplier(response: HttpResponseBase): Observable<SupplierWhDeleteModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SupplierWhDeleteModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierWhDeleteModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    listSupplier(body: SupplierWhListModelReq | undefined): Observable<SupplierWhListModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/supplier/list-supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierWhListModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierWhListModelResApiResponse>;
        }));
    }

    protected processListSupplier(response: HttpResponseBase): Observable<SupplierWhListModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SupplierWhListModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierWhListModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    detailSupplier(body: SupplierWhDetailModelReq | undefined): Observable<SupplierWhDetailModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/supplier/detail-supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierWhDetailModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierWhDetailModelResApiResponse>;
        }));
    }

    protected processDetailSupplier(response: HttpResponseBase): Observable<SupplierWhDetailModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SupplierWhDetailModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierWhDetailModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createTransaction(body: TransactionWhCreateModelReq | undefined): Observable<TransactionWhCreateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/transaction/create-transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionWhCreateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionWhCreateModelResApiResponse>;
        }));
    }

    protected processCreateTransaction(response: HttpResponseBase): Observable<TransactionWhCreateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransactionWhCreateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionWhCreateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateTransaction(body: TransactionWhUpdateModelReq | undefined): Observable<TransactionWhUpdateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/transaction/update-transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionWhUpdateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionWhUpdateModelResApiResponse>;
        }));
    }

    protected processUpdateTransaction(response: HttpResponseBase): Observable<TransactionWhUpdateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransactionWhUpdateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionWhUpdateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteTransaction(body: TransactionWhDeleteModelReq | undefined): Observable<TransactionWhDeleteModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/transaction/delete-transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionWhDeleteModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionWhDeleteModelResApiResponse>;
        }));
    }

    protected processDeleteTransaction(response: HttpResponseBase): Observable<TransactionWhDeleteModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransactionWhDeleteModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionWhDeleteModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    listTransaction(body: TransactionWhListModelReq | undefined): Observable<TransactionWhListModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/transaction/list-transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionWhListModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionWhListModelResApiResponse>;
        }));
    }

    protected processListTransaction(response: HttpResponseBase): Observable<TransactionWhListModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransactionWhListModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionWhListModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    detailTransaction(body: TransactionWhDetailModelReq | undefined): Observable<TransactionWhDetailModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/transaction/detail-transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionWhDetailModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionWhDetailModelResApiResponse>;
        }));
    }

    protected processDetailTransaction(response: HttpResponseBase): Observable<TransactionWhDetailModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TransactionWhDetailModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionWhDetailModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createUnit(body: UnitWhCreateModelReq | undefined): Observable<UnitWhCreateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/unit/create-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitWhCreateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitWhCreateModelResApiResponse>;
        }));
    }

    protected processCreateUnit(response: HttpResponseBase): Observable<UnitWhCreateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitWhCreateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitWhCreateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUnit(body: UnitWhUpdateModelReq | undefined): Observable<UnitWhUpdateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/unit/update-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitWhUpdateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitWhUpdateModelResApiResponse>;
        }));
    }

    protected processUpdateUnit(response: HttpResponseBase): Observable<UnitWhUpdateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitWhUpdateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitWhUpdateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteUnit(body: UnitWhDeleteModelReq | undefined): Observable<UnitWhDeleteModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/unit/delete-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitWhDeleteModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitWhDeleteModelResApiResponse>;
        }));
    }

    protected processDeleteUnit(response: HttpResponseBase): Observable<UnitWhDeleteModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitWhDeleteModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitWhDeleteModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    listUnit(body: UnitWhListModelReq | undefined): Observable<UnitWhListModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/unit/list-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitWhListModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitWhListModelResApiResponse>;
        }));
    }

    protected processListUnit(response: HttpResponseBase): Observable<UnitWhListModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitWhListModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitWhListModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    detailUnit(body: UnitWhDetailModelReq | undefined): Observable<UnitWhDetailModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/unit/detail-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitWhDetailModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitWhDetailModelResApiResponse>;
        }));
    }

    protected processDetailUnit(response: HttpResponseBase): Observable<UnitWhDetailModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitWhDetailModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitWhDetailModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createWarehouse(body: WarehouseCreateModelReq | undefined): Observable<WarehouseCreateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/warehouse/create-warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWarehouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseCreateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseCreateModelResApiResponse>;
        }));
    }

    protected processCreateWarehouse(response: HttpResponseBase): Observable<WarehouseCreateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WarehouseCreateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseCreateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateWarehouse(body: WarehouseUpdateModelReq | undefined): Observable<WarehouseUpdateModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/warehouse/update-warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWarehouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseUpdateModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseUpdateModelResApiResponse>;
        }));
    }

    protected processUpdateWarehouse(response: HttpResponseBase): Observable<WarehouseUpdateModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WarehouseUpdateModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseUpdateModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteWarehouse(body: WarehouseDeleteModelReq | undefined): Observable<WarehouseDeleteModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/warehouse/delete-warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWarehouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseDeleteModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseDeleteModelResApiResponse>;
        }));
    }

    protected processDeleteWarehouse(response: HttpResponseBase): Observable<WarehouseDeleteModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WarehouseDeleteModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDeleteModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    listWarehouse(body: WarehouseListModelReq | undefined): Observable<WarehouseListModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/warehouse/list-warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListWarehouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseListModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseListModelResApiResponse>;
        }));
    }

    protected processListWarehouse(response: HttpResponseBase): Observable<WarehouseListModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WarehouseListModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseListModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getWarehouseById(body: WarehouseWhDetailByIdModelReq | undefined): Observable<WarehouseWhDetailByIdModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/warehouse/get-warehouse-by-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehouseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehouseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseWhDetailByIdModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseWhDetailByIdModelResApiResponse>;
        }));
    }

    protected processGetWarehouseById(response: HttpResponseBase): Observable<WarehouseWhDetailByIdModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WarehouseWhDetailByIdModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseWhDetailByIdModelResApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    detailWarehouse(body: WarehouseWhDetailModelReq | undefined): Observable<WarehouseWhDetailModelResApiResponse> {
        let url_ = this.baseUrl + "/api/wh/warehouse/detail-warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailWarehouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseWhDetailModelResApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseWhDetailModelResApiResponse>;
        }));
    }

    protected processDetailWarehouse(response: HttpResponseBase): Observable<WarehouseWhDetailModelResApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WarehouseWhDetailModelResApiResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseWhDetailModelResApiResponse>(null as any);
    }
}

export interface ApiCreateCategoryModelReq {
    name: string;
    parentId?: string | undefined;
    fileId?: string | undefined;
}

export interface ApiListCategoryModelReq {
    pageNumber?: number;
    pageSize?: number;
}

export interface ApiListCategoryModelRes {
    id?: string;
    name?: string | undefined;
    parentId?: string | undefined;
    filePath?: string | undefined;
    fileName?: string | undefined;
}

export interface ApiListCategoryModelResIEnumerableApiResponse {
    data?: ApiListCategoryModelRes[] | undefined;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface ApiResponse {
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface Assembly {
    readonly definedTypes?: TypeInfo[] | undefined;
    readonly exportedTypes?: Type[] | undefined;
    readonly codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    readonly fullName?: string | undefined;
    readonly imageRuntimeVersion?: string | undefined;
    readonly isDynamic?: boolean;
    readonly location?: string | undefined;
    readonly reflectionOnly?: boolean;
    readonly isCollectible?: boolean;
    readonly isFullyTrusted?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    readonly modules?: Module[] | undefined;
    readonly globalAssemblyCache?: boolean;
    readonly hostContext?: number;
    securityRuleSet?: SecurityRuleSet;
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export interface ConstructorInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
}

export interface CreateNotificationModelReq {
    title?: string | undefined;
    body?: string | undefined;
    userId?: string | undefined;
    isForAnyone?: boolean | undefined;
}

export interface CreateNotificationModelRes {
}

export interface CreateNotificationModelResApiResponse {
    data?: CreateNotificationModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface CustomAttributeData {
    attributeType?: Type;
    constructor?: ConstructorInfo;
    readonly constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments?: CustomAttributeNamedArgument[] | undefined;
}

export interface CustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    readonly memberName?: string | undefined;
    readonly isField?: boolean;
}

export interface CustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export interface EventInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    readonly isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    readonly isMulticast?: boolean;
    eventHandlerType?: Type;
}

export interface Exception {
    targetSite?: MethodBase;
    readonly message?: string | undefined;
    readonly data?: { [key: string]: any; } | undefined;
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;
    readonly stackTrace?: string | undefined;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export interface FieldInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    readonly isInitOnly?: boolean;
    readonly isLiteral?: boolean;
    readonly isNotSerialized?: boolean;
    readonly isPinvokeImpl?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;
}

export interface FileUploadDTO {
    fileId?: string | undefined;
    fileName?: string | undefined;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export interface GetNotificationByUserIdModelReq {
    pageNumber?: number;
    pageSize?: number;
}

export interface GetNotificationByUserIdModelRes {
    list?: NotificationModels[] | undefined;
}

export interface GetNotificationByUserIdModelResApiResponse {
    data?: GetNotificationByUserIdModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface ICustomAttributeProvider {
}

export interface Int32ApiResponse {
    data?: number;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface IntPtr {
}

export interface InventoryWhCreateModelReq {
}

export interface InventoryWhCreateModelRes {
}

export interface InventoryWhCreateModelResApiResponse {
    data?: InventoryWhCreateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface InventoryWhDeleteModelReq {
}

export interface InventoryWhDeleteModelRes {
}

export interface InventoryWhDeleteModelResApiResponse {
    data?: InventoryWhDeleteModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface InventoryWhListModelReq {
}

export interface InventoryWhListModelRes {
}

export interface InventoryWhListModelResApiResponse {
    data?: InventoryWhListModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface InventoryWhUpdateModelReq {
}

export interface InventoryWhUpdateModelRes {
}

export interface InventoryWhUpdateModelResApiResponse {
    data?: InventoryWhUpdateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface ItemFileManagerRequestDTO {
    pageNumber?: number;
    pageSize?: number;
}

export interface ItemFileManagerResponseDTO {
    fileName?: string | undefined;
    filePath?: string | undefined;
}

export interface ItemFileManagerResponseDTOIEnumerableApiResponse {
    data?: ItemFileManagerResponseDTO[] | undefined;
    isNormal?: boolean;
    metaData?: MetaData;
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export interface MemberInfo {
    memberType?: MemberTypes;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export interface MetaData {
    statusCode?: string | undefined;
    message?: string | undefined;
    exceptionExtra?: Exception;
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export interface MethodBase {
    memberType?: MemberTypes;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export interface MethodInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;
}

export interface Module {
    assembly?: Assembly;
    readonly fullyQualifiedName?: string | undefined;
    readonly name?: string | undefined;
    readonly mdStreamVersion?: number;
    readonly moduleVersionId?: string;
    readonly scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;
}

export interface ModuleHandle {
    readonly mdStreamVersion?: number;
}

export interface NotificationModels {
    id?: string;
    createdDate: Date;
    updatedDate: Date;
    createdBy: string;
    updatedBy: string;
    status?: number;
    title?: string | undefined;
    body?: string | undefined;
    userId?: string | undefined;
    isForAnyone?: boolean | undefined;
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export interface ParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    readonly name?: string | undefined;
    parameterType?: Type;
    readonly position?: number;
    readonly isIn?: boolean;
    readonly isLcid?: boolean;
    readonly isOptional?: boolean;
    readonly isOut?: boolean;
    readonly isRetval?: boolean;
    readonly defaultValue?: any | undefined;
    readonly rawDefaultValue?: any | undefined;
    readonly hasDefaultValue?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;
}

export interface ProductWhCreateModelReq {
    barCode?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    supplierId?: string;
    unitId?: string;
}

export interface ProductWhCreateModelRes {
}

export interface ProductWhCreateModelResApiResponse {
    data?: ProductWhCreateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface ProductWhDeleteModelReq {
    id?: string;
}

export interface ProductWhDeleteModelRes {
}

export interface ProductWhDeleteModelResApiResponse {
    data?: ProductWhDeleteModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface ProductWhDetailModelReq {
    id?: string;
}

export interface ProductWhDetailModelRes {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    supplierId?: string;
    supplierName?: string | undefined;
    unitId?: string;
    unitName?: string | undefined;
    barCode?: string | undefined;
}

export interface ProductWhDetailModelResApiResponse {
    data?: ProductWhDetailModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface ProductWhEntity {
    id?: string;
    createdDate: Date;
    updatedDate: Date;
    createdBy: string;
    updatedBy: string;
    status?: number;
    barCode?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    supplierId?: string;
    unitId?: string;
    supplier?: SupplierWhEntity;
    unit?: UnitWhEntity;
    transactionDetails?: TransactionDetailWhEntity[] | undefined;
}

export interface ProductWhListModelReq {
    pageNumber?: number;
    pageSize?: number;
}

export interface ProductWhListModelRes {
    list?: ProductWhModel[] | undefined;
}

export interface ProductWhListModelResApiResponse {
    data?: ProductWhListModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface ProductWhModel {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    supplierId?: string;
    supplierName?: string | undefined;
    unitId?: string;
    unitName?: string | undefined;
    barCode?: string | undefined;
}

export interface ProductWhUpdateModelReq {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    supplierId?: string;
    unitId?: string;
}

export interface ProductWhUpdateModelRes {
}

export interface ProductWhUpdateModelResApiResponse {
    data?: ProductWhUpdateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export interface PropertyInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    readonly isSpecialName?: boolean;
    readonly canRead?: boolean;
    readonly canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;
}

export interface RuntimeFieldHandle {
    value?: IntPtr;
}

export interface RuntimeMethodHandle {
    value?: IntPtr;
}

export interface RuntimeTypeHandle {
    value?: IntPtr;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export interface StructLayoutAttribute {
    readonly typeId?: any | undefined;
    value?: LayoutKind;
}

export interface SubTransactionWhCreateModelReq {
    productId?: string;
    unitPrice?: number;
    quantity?: number;
    dateOfManufacture?: Date | undefined;
    dateOfExpired?: Date | undefined;
}

export interface SupplierModel {
    id?: string;
    createdDate?: Date | undefined;
    updatedDate?: Date | undefined;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
}

export interface SupplierWhCreateModelReq {
    name?: string | undefined;
    address?: string | undefined;
}

export interface SupplierWhCreateModelRes {
    id?: string;
    createdDate?: Date | undefined;
    updatedDate?: Date | undefined;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
}

export interface SupplierWhCreateModelResApiResponse {
    data?: SupplierWhCreateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface SupplierWhDeleteModelReq {
    id?: string;
}

export interface SupplierWhDeleteModelRes {
}

export interface SupplierWhDeleteModelResApiResponse {
    data?: SupplierWhDeleteModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface SupplierWhDetailModelReq {
    id?: string;
}

export interface SupplierWhDetailModelRes {
    id?: string;
    createdDate?: Date | undefined;
    updatedDate?: Date | undefined;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
}

export interface SupplierWhDetailModelResApiResponse {
    data?: SupplierWhDetailModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface SupplierWhEntity {
    id?: string;
    createdDate: Date;
    updatedDate: Date;
    createdBy: string;
    updatedBy: string;
    status?: number;
    name?: string | undefined;
    address?: string | undefined;
    products?: ProductWhEntity[] | undefined;
}

export interface SupplierWhListModelReq {
    pageNumber?: number;
    pageSize?: number;
}

export interface SupplierWhListModelRes {
    list?: SupplierModel[] | undefined;
}

export interface SupplierWhListModelResApiResponse {
    data?: SupplierWhListModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface SupplierWhUpdateModelReq {
    id?: string;
    name?: string | undefined;
    address?: string | undefined;
}

export interface SupplierWhUpdateModelRes {
    id?: string;
    name?: string | undefined;
    address?: string | undefined;
}

export interface SupplierWhUpdateModelResApiResponse {
    data?: SupplierWhUpdateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface TransactionDetailWhEntity {
    id?: string;
    createdDate: Date;
    updatedDate: Date;
    createdBy: string;
    updatedBy: string;
    status?: number;
    transactionId?: string;
    productId?: string;
    unitPrice?: number;
    quantity?: number;
    dateOfManufacture?: Date | undefined;
    dateOfExpired?: Date | undefined;
    transactions?: TransactionWhEntity;
    products?: ProductWhEntity;
}

export interface TransactionWhCreateModelReq {
    transactionCode?: string | undefined;
    transactionType?: string | undefined;
    dateOfImport?: Date | undefined;
    details?: SubTransactionWhCreateModelReq[] | undefined;
}

export interface TransactionWhCreateModelRes {
}

export interface TransactionWhCreateModelResApiResponse {
    data?: TransactionWhCreateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface TransactionWhDeleteModelReq {
}

export interface TransactionWhDeleteModelRes {
}

export interface TransactionWhDeleteModelResApiResponse {
    data?: TransactionWhDeleteModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface TransactionWhDetailModelReq {
    id?: string;
}

export interface TransactionWhDetailModelRes {
}

export interface TransactionWhDetailModelResApiResponse {
    data?: TransactionWhDetailModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface TransactionWhEntity {
    id?: string;
    createdDate: Date;
    updatedDate: Date;
    createdBy: string;
    updatedBy: string;
    status?: number;
    transactionCode?: string | undefined;
    transactionType?: string | undefined;
    transactionDate?: Date | undefined;
    totalAmount?: number;
    dateOfImport?: Date | undefined;
    transactionDetails?: TransactionDetailWhEntity[] | undefined;
}

export interface TransactionWhListModelReq {
}

export interface TransactionWhListModelRes {
}

export interface TransactionWhListModelResApiResponse {
    data?: TransactionWhListModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface TransactionWhUpdateModelReq {
}

export interface TransactionWhUpdateModelRes {
}

export interface TransactionWhUpdateModelResApiResponse {
    data?: TransactionWhUpdateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface Type {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly isFunctionPointer?: boolean;
    readonly isUnmanagedFunctionPointer?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export interface TypeInfo {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly isFunctionPointer?: boolean;
    readonly isUnmanagedFunctionPointer?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
    readonly genericTypeParameters?: Type[] | undefined;
    readonly declaredConstructors?: ConstructorInfo[] | undefined;
    readonly declaredEvents?: EventInfo[] | undefined;
    readonly declaredFields?: FieldInfo[] | undefined;
    readonly declaredMembers?: MemberInfo[] | undefined;
    readonly declaredMethods?: MethodInfo[] | undefined;
    readonly declaredNestedTypes?: TypeInfo[] | undefined;
    readonly declaredProperties?: PropertyInfo[] | undefined;
    readonly implementedInterfaces?: Type[] | undefined;
}

export interface UnitWhCreateModelReq {
    name?: string | undefined;
}

export interface UnitWhCreateModelRes {
}

export interface UnitWhCreateModelResApiResponse {
    data?: UnitWhCreateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface UnitWhDeleteModelReq {
    id?: string;
}

export interface UnitWhDeleteModelRes {
}

export interface UnitWhDeleteModelResApiResponse {
    data?: UnitWhDeleteModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface UnitWhDetailModelReq {
    id?: string | undefined;
}

export interface UnitWhDetailModelRes {
    id?: string;
    name?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
}

export interface UnitWhDetailModelResApiResponse {
    data?: UnitWhDetailModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface UnitWhEntity {
    id?: string;
    createdDate: Date;
    updatedDate: Date;
    createdBy: string;
    updatedBy: string;
    status?: number;
    name?: string | undefined;
    products?: ProductWhEntity[] | undefined;
}

export interface UnitWhListModelReq {
    pageNumber?: number;
    pageSize?: number;
}

export interface UnitWhListModelRes {
    list?: UnitWhModel[] | undefined;
}

export interface UnitWhListModelResApiResponse {
    data?: UnitWhListModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface UnitWhModel {
    id?: string;
    name?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
}

export interface UnitWhUpdateModelReq {
    id?: string;
    name?: string | undefined;
}

export interface UnitWhUpdateModelRes {
}

export interface UnitWhUpdateModelResApiResponse {
    data?: UnitWhUpdateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface UploadFileResponseDTO {
    fileIds?: FileUploadDTO[] | undefined;
}

export interface UploadFileResponseDTOApiResponse {
    data?: UploadFileResponseDTO;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface WarehouseCreateModelReq {
    name: string;
    address: string;
}

export interface WarehouseCreateModelRes {
}

export interface WarehouseCreateModelResApiResponse {
    data?: WarehouseCreateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface WarehouseDeleteModelReq {
    id: string;
}

export interface WarehouseDeleteModelRes {
}

export interface WarehouseDeleteModelResApiResponse {
    data?: WarehouseDeleteModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface WarehouseInfoModel {
    id?: string;
    name?: string | undefined;
    address?: string | undefined;
}

export interface WarehouseListModelReq {
    pageNumber?: number;
    pageSize?: number;
}

export interface WarehouseListModelRes {
    listWarehouse?: WarehouseInfoModel[] | undefined;
}

export interface WarehouseListModelResApiResponse {
    data?: WarehouseListModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface WarehouseUpdateModelReq {
    id?: string;
    name?: string | undefined;
    address?: string | undefined;
}

export interface WarehouseUpdateModelRes {
}

export interface WarehouseUpdateModelResApiResponse {
    data?: WarehouseUpdateModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface WarehouseWhDetailByIdModelReq {
    id?: string;
}

export interface WarehouseWhDetailByIdModelRes {
    id?: string;
    name?: string | undefined;
    address?: string | undefined;
}

export interface WarehouseWhDetailByIdModelResApiResponse {
    data?: WarehouseWhDetailByIdModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface WarehouseWhDetailModelReq {
    id?: string;
}

export interface WarehouseWhDetailModelRes {
    id?: string;
    createdDate: Date;
    updatedDate: Date;
    createdBy: string;
    updatedBy: string;
    status?: number;
    name?: string | undefined;
    address?: string | undefined;
    transactions?: TransactionWhEntity[] | undefined;
}

export interface WarehouseWhDetailModelResApiResponse {
    data?: WarehouseWhDetailModelRes;
    isNormal?: boolean;
    metaData?: MetaData;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiWarehouseException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiWarehouseException = true;

    static isApiWarehouseException(obj: any): obj is ApiWarehouseException {
        return obj.isApiWarehouseException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiWarehouseException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}